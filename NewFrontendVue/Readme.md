# Frontend Integration Plan for CRM Loan Management System

This document outlines the integration plan for the Vue 3 frontend with the TypeScript SDK generated by `openapi-typescript-codegen`.

## Table of Contents

1. [Authentication Module](#authentication-module)
2. [Applications Module](#applications-module)
3. [Borrowers Module](#borrowers-module)
4. [Documents Module](#documents-module)
5. [Brokers Module](#brokers-module)
6. [Products Module](#products-module)
7. [Reminders Module](#reminders-module)
8. [Reports Module](#reports-module)
9. [Notifications Module](#notifications-module)
10. [Common Components](#common-components)
11. [Error Handling Patterns](#error-handling-patterns)
12. [State Management](#state-management)

## Authentication Module

### Components Needed
- `LoginView.vue` - Login page
- `RegisterView.vue` - Registration page (if applicable)
- `ProfileView.vue` - User profile page
- `AuthLayout.vue` - Layout for authentication pages

### SDK Services to Use
- `UsersService.usersAuthLoginCreate()` - For user login
- `UsersService.usersAuthRefreshCreate()` - For token refresh
- `UsersService.usersProfileRetrieve()` - For getting user profile
- `UsersService.usersProfileUpdateUpdate()` - For updating user profile

### State Management
- Create an auth store using Pinia:
```typescript
// src/stores/auth.ts
import { defineStore } from 'pinia';
import { UsersService } from '@/api';
import type { User } from '@/api/models';

export const useAuthStore = defineStore('auth', {
  state: () => ({
    user: null as User | null,
    token: localStorage.getItem('token') || null,
    refreshToken: localStorage.getItem('refreshToken') || null,
    loading: false,
    error: null as string | null,
  }),
  
  getters: {
    isAuthenticated: (state) => !!state.token,
    userRole: (state) => state.user?.role || null,
  },
  
  actions: {
    async login(username: string, password: string) {
      this.loading = true;
      this.error = null;
      try {
        // Implementation will depend on actual API response structure
        const response = await UsersService.usersAuthLoginCreate();
        this.token = response.access;
        this.refreshToken = response.refresh;
        localStorage.setItem('token', this.token);
        localStorage.setItem('refreshToken', this.refreshToken);
        await this.fetchUserProfile();
      } catch (error) {
        this.error = 'Login failed. Please check your credentials.';
        console.error('Login error:', error);
      } finally {
        this.loading = false;
      }
    },
    
    async fetchUserProfile() {
      try {
        const user = await UsersService.usersProfileRetrieve();
        this.user = user;
      } catch (error) {
        console.error('Error fetching user profile:', error);
      }
    },
    
    logout() {
      this.user = null;
      this.token = null;
      this.refreshToken = null;
      localStorage.removeItem('token');
      localStorage.removeItem('refreshToken');
    }
  }
});
```

### Example Login Component
```vue
<template>
  <div class="login-container">
    <form @submit.prevent="handleLogin">
      <div class="form-group">
        <label for="username">Username</label>
        <input 
          type="text" 
          id="username" 
          v-model="username" 
          required
        />
      </div>
      
      <div class="form-group">
        <label for="password">Password</label>
        <input 
          type="password" 
          id="password" 
          v-model="password" 
          required
        />
      </div>
      
      <div v-if="authStore.error" class="error-message">
        {{ authStore.error }}
      </div>
      
      <button 
        type="submit" 
        :disabled="authStore.loading"
      >
        {{ authStore.loading ? 'Logging in...' : 'Login' }}
      </button>
    </form>
  </div>
</template>

<script lang="ts" setup>
import { ref } from 'vue';
import { useAuthStore } from '@/stores/auth';
import { useRouter } from 'vue-router';

const username = ref('');
const password = ref('');
const authStore = useAuthStore();
const router = useRouter();

const handleLogin = async () => {
  await authStore.login(username.value, password.value);
  if (authStore.isAuthenticated) {
    router.push('/dashboard');
  }
};
</script>
```

### Error Handling
- Display validation errors below form fields
- Show API errors in a notification component
- Implement token refresh logic for expired tokens

## Common Components

### Reusable UI Components
- `BaseButton.vue` - Reusable button component with different styles
- `BaseInput.vue` - Reusable input component with validation
- `BaseSelect.vue` - Reusable select component
- `BaseTextarea.vue` - Reusable textarea component
- `BaseDatePicker.vue` - Reusable date picker component
- `BaseModal.vue` - Reusable modal component
- `BaseTable.vue` - Reusable table component with sorting and pagination
- `BaseCard.vue` - Reusable card component
- `BaseAlert.vue` - Reusable alert component for notifications
- `BasePagination.vue` - Reusable pagination component
- `BaseDropdown.vue` - Reusable dropdown component
- `BaseTab.vue` - Reusable tab component
- `BaseTabPanel.vue` - Reusable tab panel component
- `BaseFileUpload.vue` - Reusable file upload component

### Example BaseInput Component
```vue
<template>
  <div class="base-input">
    <label v-if="label" :for="id" class="input-label">
      {{ label }}
      <span v-if="required" class="required-indicator">*</span>
    </label>
    
    <div class="input-wrapper">
      <input
        :id="id"
        :type="type"
        :value="modelValue"
        @input="updateValue"
        :placeholder="placeholder"
        :disabled="disabled"
        :required="required"
        :class="{ 'has-error': !!error }"
        v-bind="$attrs"
      />
      
      <div v-if="error" class="error-message">
        {{ error }}
      </div>
      
      <div v-if="helpText" class="help-text">
        {{ helpText }}
      </div>
    </div>
  </div>
</template>

<script lang="ts" setup>
import { computed } from 'vue';

const props = defineProps({
  modelValue: {
    type: [String, Number],
    default: ''
  },
  label: {
    type: String,
    default: ''
  },
  type: {
    type: String,
    default: 'text'
  },
  placeholder: {
    type: String,
    default: ''
  },
  required: {
    type: Boolean,
    default: false
  },
  disabled: {
    type: Boolean,
    default: false
  },
  error: {
    type: String,
    default: ''
  },
  helpText: {
    type: String,
    default: ''
  },
  id: {
    type: String,
    default: ''
  }
});

const emit = defineEmits(['update:modelValue']);

const updateValue = (event: Event) => {
  const target = event.target as HTMLInputElement;
  emit('update:modelValue', target.value);
};

const inputId = computed(() => props.id || `input-${Math.random().toString(36).substring(2, 9)}`);
</script>
```

## Error Handling Patterns

### Global Error Handler
Create a global error handler to catch and process unhandled errors:

```typescript
// src/utils/errorHandler.ts
import { useNotificationStore } from '@/stores/notification';

export function setupGlobalErrorHandlers() {
  const notificationStore = useNotificationStore();
  
  // Handle uncaught errors
  window.addEventListener('error', (event) => {
    console.error('Uncaught error:', event.error);
    notificationStore.showError('An unexpected error occurred. Please try again.');
  });
  
  // Handle unhandled promise rejections
  window.addEventListener('unhandledrejection', (event) => {
    console.error('Unhandled promise rejection:', event.reason);
    notificationStore.showError('An operation failed to complete. Please try again.');
  });
}

// API error handler
export function handleApiError(error: any, defaultMessage = 'An error occurred while communicating with the server.') {
  const notificationStore = useNotificationStore();
  
  // Log the error
  console.error('API Error:', error);
  
  // Extract error message from response if available
  let errorMessage = defaultMessage;
  
  if (error.response) {
    // The request was made and the server responded with a status code
    // that falls out of the range of 2xx
    const data = error.response.data;
    
    if (data.detail) {
      errorMessage = data.detail;
    } else if (data.message) {
      errorMessage = data.message;
    } else if (typeof data === 'string') {
      errorMessage = data;
    } else if (Object.keys(data).length > 0) {
      // Handle validation errors (field-specific errors)
      const firstField = Object.keys(data)[0];
      const firstError = data[firstField];
      
      if (Array.isArray(firstError) && firstError.length > 0) {
        errorMessage = `${firstField}: ${firstError[0]}`;
      } else if (typeof firstError === 'string') {
        errorMessage = `${firstField}: ${firstError}`;
      }
    }
    
    // Handle specific HTTP status codes
    switch (error.response.status) {
      case 401:
        errorMessage = 'Authentication required. Please log in again.';
        // Redirect to login page or refresh token
        break;
      case 403:
        errorMessage = 'You do not have permission to perform this action.';
        break;
      case 404:
        errorMessage = 'The requested resource was not found.';
        break;
      case 500:
        errorMessage = 'Server error. Please try again later.';
        break;
    }
  } else if (error.request) {
    // The request was made but no response was received
    errorMessage = 'No response from server. Please check your internet connection.';
  }
  
  // Show error notification
  notificationStore.showError(errorMessage);
  
  // Return the error message for component-level handling
  return errorMessage;
}

// Form validation error handler
export function handleFormErrors(errors: Record<string, any>) {
  const formattedErrors: Record<string, string> = {};
  
  Object.entries(errors).forEach(([field, error]) => {
    if (Array.isArray(error)) {
      formattedErrors[field] = error[0];
    } else if (typeof error === 'string') {
      formattedErrors[field] = error;
    } else {
      formattedErrors[field] = 'Invalid value';
    }
  });
  
  return formattedErrors;
}
```

### Component-Level Error Handling
Example of component-level error handling:

```vue
<template>
  <div class="form-container">
    <base-alert v-if="error" type="error" :message="error" @close="error = ''" />
    
    <form @submit.prevent="handleSubmit">
      <base-input
        v-model="formData.name"
        label="Name"
        required
        :error="formErrors.name"
      />
      
      <!-- Other form fields -->
      
      <div class="form-actions">
        <base-button type="submit" :loading="loading">Submit</base-button>
      </div>
    </form>
  </div>
</template>

<script lang="ts" setup>
import { ref, reactive } from 'vue';
import { handleApiError, handleFormErrors } from '@/utils/errorHandler';
import BaseInput from '@/components/BaseInput.vue';
import BaseButton from '@/components/BaseButton.vue';
import BaseAlert from '@/components/BaseAlert.vue';

const loading = ref(false);
const error = ref('');
const formErrors = reactive<Record<string, string>>({});

const formData = reactive({
  name: '',
  // Other form fields
});

const validateForm = () => {
  const errors: Record<string, string> = {};
  
  if (!formData.name.trim()) {
    errors.name = 'Name is required';
  }
  
  // Other validations
  
  return errors;
};

const handleSubmit = async () => {
  // Clear previous errors
  error.value = '';
  Object.keys(formErrors).forEach(key => delete formErrors[key]);
  
  // Validate form
  const validationErrors = validateForm();
  if (Object.keys(validationErrors).length > 0) {
    Object.assign(formErrors, validationErrors);
    return;
  }
  
  loading.value = true;
  
  try {
    // Call API service
    // await SomeService.createSomething(formData);
    
    // Handle success
  } catch (err) {
    // Handle API error
    error.value = handleApiError(err);
    
    // Handle validation errors from API
    if (err.response?.data && typeof err.response.data === 'object') {
      const apiFormErrors = handleFormErrors(err.response.data);
      Object.assign(formErrors, apiFormErrors);
    }
  } finally {
    loading.value = false;
  }
};
</script>
```

## State Management

### Pinia Store Structure
Organize Pinia stores by feature module:

```
src/stores/
├── auth.ts           # Authentication state
├── applications.ts   # Applications state
├── borrowers.ts      # Borrowers state
├── documents.ts      # Documents state
├── brokers.ts        # Brokers state
├── products.ts       # Products state
├── reminders.ts      # Reminders state
├── reports.ts        # Reports state
├── notifications.ts  # Notifications state
└── index.ts          # Store setup and exports
```

### Store Setup
```typescript
// src/stores/index.ts
import { createPinia } from 'pinia';

const pinia = createPinia();

export default pinia;
```

### Store Usage in Components
```vue
<script lang="ts" setup>
import { useAuthStore } from '@/stores/auth';
import { useApplicationsStore } from '@/stores/applications';
import { storeToRefs } from 'pinia';

const authStore = useAuthStore();
const applicationsStore = useApplicationsStore();

// Destructure with storeToRefs to maintain reactivity
const { user, isAuthenticated } = storeToRefs(authStore);
const { applications, loading, error } = storeToRefs(applicationsStore);

// Use store actions
const fetchData = async () => {
  if (isAuthenticated.value) {
    await applicationsStore.fetchApplications();
  }
};
</script>
```

### API Service Integration
Create a centralized API service configuration:

```typescript
// src/services/api.ts
import { OpenAPI } from '@/api';
import { useAuthStore } from '@/stores/auth';

export function setupApiInterceptors() {
  const authStore = useAuthStore();
  
  // Configure base URL
  OpenAPI.BASE = import.meta.env.VITE_API_BASE_URL || '/api';
  
  // Configure request interceptor to add auth token
  OpenAPI.TOKEN = () => authStore.token || '';
  
  // Configure error handling
  OpenAPI.WITH_CREDENTIALS = true;
}
```

### Composables for Common Functionality
Create composables for reusable functionality:

```typescript
// src/composables/usePagination.ts
import { ref, computed } from 'vue';

export function usePagination(fetchFunction: (page: number) => Promise<void>) {
  const currentPage = ref(1);
  const totalPages = ref(1);
  const totalItems = ref(0);
  const itemsPerPage = ref(10);
  
  const hasPrevious = computed(() => currentPage.value > 1);
  const hasNext = computed(() => currentPage.value < totalPages.value);
  
  const goToPage = async (page: number) => {
    if (page < 1 || page > totalPages.value) return;
    currentPage.value = page;
    await fetchFunction(page);
  };
  
  const nextPage = () => goToPage(currentPage.value + 1);
  const previousPage = () => goToPage(currentPage.value - 1);
  
  const updatePaginationInfo = (count: number, next: string | null, previous: string | null) => {
    totalItems.value = count;
    totalPages.value = Math.ceil(count / itemsPerPage.value);
  };
  
  return {
    currentPage,
    totalPages,
    totalItems,
    itemsPerPage,
    hasPrevious,
    hasNext,
    goToPage,
    nextPage,
    previousPage,
    updatePaginationInfo
  };
}
```

This completes the frontend integration plan for the CRM Loan Management System. The plan provides a comprehensive guide for implementing the frontend using the TypeScript SDK generated by `openapi-typescript-codegen`, with Vue 3, TypeScript, and the Composition API.
